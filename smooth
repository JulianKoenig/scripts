#! /bin/bash
# smooth (BASH script) -- git/svn/hg wrapper
#
# see [instructions](doc/s for smooth source control.md)

SELF=$(basename $0)


git_transfer()
{
  set -e

  b=$(git branch | sed -n 's/^\* \(.*\)/\1/p')
  b_remote=$(git config --get "branch.$b.remote")
  
  git push $b_remote $b
}


git_commit()
{
  # Figure out if a fast-forward merge is possible
  echo 'Running "git pull"...'
  git pull
  echo '...done.'
  sleep 1
  git commit -a && git_transfer
}


git_commit_paranoid()
{
  local needs_merge
  ## if git status | grep -q '^nothing to commit'

  # Figure out if a fast-forward merge is possible
  git fetch
  if git branch -v | grep -q '^\* [^ ]* [0-9a-f]* \[behind'
  then
    ## needs_merge=y
    git stash save
    git merge FETCH_HEAD
    git stash pop || echo "smooth: WARNING: unstaged changes didn't re-apply; fix manually and run 'git stash drop'" >&2
  fi
  git commit -a && git_transfer
  ## if [ "$needs_merge" = y ] ; then
  ## fi
}


# *** MAINLINE ***
declare -A r_git r_svn r_hg
. $(dirname "$0")/_s.sh
r_git[commit]=git_commit
r_git[c]=git_commit
r_svn[status]="svn status"
r_svn[s]="svn status"
r_svn[st]="svn status"
r_svn[track]=${r_svn[add]}
r_git[status]="git status"
r_git[s]="git status"
r_git[st]="git status"
r_git[track]=${r_git[add]}
r_hg[status]="hg status"
r_hg[s]="hg status"
r_hg[st]="hg status"
r_hg[track]=${r_hg[add]}
r_git[transfer]="git_transfer"
r_git[t]="git_transfer"


## set -x

# determine arg, i.e. which smooth subcommand to run
case $SELF in
  s|smooth)
    if [ $# = 0 ] ; then
      arg=status
    else
      arg=$1 
      shift
    fi
    ;;
  s-*) arg=${SELF#s-} ;;
  *)
    echo "smooth: ERROR: run as unknown name" >&2
    exit 4
    ;;
esac


fn()
{
  # determine repository type
  if [ -d .svn ] ; then
    rtype=svn
  else
    # TO-DO: cache path rtypes
    d=$PWD
    while [ "$d" != / ] ; do
      if [ -d "$d"/.git ] ; then
	rtype=git
	break
      fi
      d=$(dirname "$d")
    done
  fi
  if [ -z "$rtype" ] ; then
    ## echo "smooth: WARNING: no revision control directory found in $PWD or parents" >&2
    echo "smooth: ERROR: no revision control directory found in $PWD or parents" >&2
    exit 3
  fi

  if [ -z "$(eval echo \${r_$rtype[$arg]})" ] ; then
    echo "smooth: ERROR: operation '$arg' not supported for $rtype" >&2
    exit 4
  fi
  ## set -x
  eval \${r_$rtype[$arg]} '"$@"'
}


if [[ $arg == [mr]* ]] ; then
  # find a common prefix
  echo not yet
else
  if [ -n "$1" ] ; then
    # Process each argument by recursively calling this script
    for dir do
      if [ -d "$dir" ] ; then
	(cd "$dir" && fn)   ## "$@"
      else
	# FIXME: this is a hack... should take refspec(s) as an option arg
	if [[ "$dir" != */* || "$dir" = origin/* ]] ; then
	  fn
	else
	  (cd "$(dirname "$dir")" && fn "${dir##*/}")   ## "$@"
	fi
      fi
    done
  else
    # No arguments so just get the job done
    fn
  fi
fi
