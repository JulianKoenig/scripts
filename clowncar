#! /bin/bash
# clowncar (BASH script) -- wrapper for useradd that manages SSH public key

self=$0
## ... clowncar

GRACE_PERIOD=3
USERADD=/usr/sbin/useradd


# creates a version of this script that acts similarly, but has the parameters
# and SSH key "baked in"
clowncar_factory()
{
  set_ssh_key

  # wrap args in single quotes.  For each existing single quote within an arg,
  #   1) end quoting
  #   2) inserted a backslash-quoted single quote
  #   3) restart quoting
  # Note that the first argument doesn't have a single quote added, because
  # that's done by the concatenation of subsequent arguments.
  args="'${1//\'/\'\\\'\'}"
  shift
  if [ $debug -gt 0 ] ; then echo "$args" ; fi

  for arg ; do
    args="$args' '${arg//\'/\'\\\'\'}"
    if [ $debug -gt 0 ] ; then echo "$args" ; fi
  done

  # add the final argument's single quote
  args="$args'"

  # splice all info currently held into the output
  sed -e "s%^set_ssh_key$%ssh_key='$ssh_key'%" \
      -e "2 s/clowncar/clowncar_$username/" \
      -e "/^set_ssh_key()/,/^}/ d" \
      -e "/^clowncar_factory()/,/^}/ d" \
      -e "/^# -- option handling --/,/^# == sanity checking ==/ d" \
      -e "/^# -- defaults --/,/^# -- end defaults --/ c\
locked=$locked\n\
username=$username\n\
set -- $args" \
    $self > "$output_filename"
  chmod a+x "$output_filename"
}


set_ssh_key()
{
  # Only prompt if running on a terminal
  if [ -t 0 ] ; then
    echo "Please paste in the desired SSH key (including command-forcing):"
  fi
  read ssh_key
}


# *** MAINLINE ***
# == pre-check ==
if [ -z "$BASH_VERSION" ] ; then
  echo "${self}: Error: script must be run as a program" >&2
  exit 4
fi
# == command-line parsing ==
# -- defaults --
locked=n
# -- end defaults --
debug=0

# -- option handling --
# this is handled strangely because the rest of the arguments are passed to
# useradd
while [ x"$1" = x-L -o x"$1" = x-O -o x"$1" = x-V ] ; do
  if [ x"$1" = x-O ] ; then
    output_filename="$2"
    shift   # get rid of the option; argument gets done below
  elif [ x"$1" = x-L ] ; then
    locked=y
  elif [ x"$1" = x-V ] ; then
    debug=1
  fi

  shift
done

# -- argument checking --
if [ $# -lt 1 ] ; then
  echo "${self}: Error: username (and other useradd arguments) required" >&2
  exit 1
fi

set -e

# -- argument handling --
username="${@: -1}"
# ... in sh, use "eval last=\${$#}" or "for username; do : ; done" instead of the previous line

# == preparation ==
if [ -n "$output_filename" ] ; then
  # mode switch!
  clowncar_factory "$@"
  exit $?
fi

# == sanity checking ==
# TO-DO: test for valid username

# == processing ==
if getent passwd $username > /dev/null
then
  echo "Notice: User $username already exists."
else
  echo "Creating user $username."
  $USERADD "$@"
  if [ ! $locked = y ] ; then
    # delete the user's password and mark it as expired
    passwd -d $username
    ## passwd -e $username
    chage -d 0 $username

    # auto-expire the user if they still haven't logged in after 3 days
    chage --inactive=$GRACE_PERIOD $username
  fi
fi

homedir=$(getent passwd $username | cut -f6 -d:)

if [ ! -d $homedir ] ; then
  echo "${self}: Error: User $username's home directory doesn't exist" >&2
  exit 3
fi

set_ssh_key

install_it=y
if [ -f $homedir/.ssh/authorized_keys ] ; then
  if grep -q "$ssh_key" $homedir/.ssh/authorized_keys
  then
    echo "Notice: User's key is already installed"
    install_it=n
  fi
else
  # Create an empty authorized_keys file (and the directory if needed) with the
  # correct ownership and permissions
  if [ ! -d $homedir/.ssh ] ; then
    install -o $username -g $username -d $homedir/.ssh
  fi
  install -o $username -g $username -m 600 /dev/null $homedir/.ssh/authorized_keys
fi

if [ $install_it = y ] ; then
  echo "Installing key"
  echo "$ssh_key" >> $homedir/.ssh/authorized_keys
fi
